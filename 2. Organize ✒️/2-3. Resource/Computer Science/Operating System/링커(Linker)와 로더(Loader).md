>(1) 날짜: 2025.03.05
>(2) 태그(주제/카테고리): #CS #OS #Linker #Loader #ELF #PE #Mach-O

>(3) Link
- [[Operating System]]
---

우리가 사용하는 프로그램은 **링커**와 **로더**에 의해 실행될 수 있다. 링커와 로더에 대해 알아보기 전에 우리는 컴파일 과정에 대해 먼저 알아야 한다.

![[Pasted image 20250305235421.png]]

C 프로그램을 예로 들자면, 작성된 소스 코드를 C 컴파일러로 **컴파일**한다. 이는 어셈블리어(Assembly language)로 번역되며, 어셈블러(Assembler)에 의해 오프젝트 파일로 번역된다. 변환된 오브젝트 파일들은 **링커에 의해 연결**되어 하나의 실행 파일로 만들어진다. **로더**가 이 실행 파일을 **적절한 메모리 위치에 적재**하면 프로그램이 실행된다.

# 링커(Linker)
링커는 컴파일러가 생성한 **오브젝트 파일**과 다른 코드 조각을 연결하여 실행 가능한(.exe 확장자를 가진) 파일을 생성한다. 

링커가 있는 이유는 **별도의 컴파일(Separate compilation)** 을 위해서이다. 별도로 컴파일하기 때문에 하나의 파일에 수정사항이 발생하더라도 전체를 다시 컴파일할 필요는 없다.

이렇게 만들어진 오브젝트 파일들을 엮어서 하나의 프로그램으로 만든다.

## 오브젝트 파일(object file)
컴파일러 혹은 어셈블러가 소스 코드를 번역한 **결과 파일**로, 링커가 연결하기 적합한 **표준 형태(ELF, Executable and Linkable Format)** 를 따르고 있다.

\*Windows에서는 **PE(Portable Executable)**, macOS는 **Mach-O** 형식을 사용한다.

아직 주소가 완전히 확정되지 않은 상태(재배치 필요한 상태) 기 때문에 **오브젝트 파일 자체로는 실행할 수 없다.**

### ELF(Executable and Linkable Format)
>ELF는 실행 파일, 목적 파일, 공유 라이브러리 그리고 코어 덤프를 위한 **표준 파일 형식**이다. 각 ELF 파일은 하나의 ELF 헤더와 파일 데이터로 이루어진다.

오브젝트 파일은 Linux/Unix 환경에서 ELF 표준 형식을 따르므로, 해당 포맷에 따라 아래와 같은 섹션으로 나누어진다. 실행 파일과 오브젝트 파일은 동일하게 ELF 표준을 따르지만 **구성 요소에서의 차이**가 있다.
![[Pasted image 20250306114555.png]]
- ELF header
	- [이 위키 백과 문서](https://ko.wikipedia.org/wiki/ELF_%ED%8C%8C%EC%9D%BC_%ED%98%95%EC%8B%9D)에서 자세한 헤더 정보를 확인할 수 있다.
	- 해당 파일의 **메타데이터**를 포함한다.
- 파일 데이터
	- Program header table
	- Section header table
	- `.text` 섹션
		- CPU가 실행할 **기계어 코드(명령어)** 가 포함됨
	- `.data`/ `.bss`/ `.rodata` 섹션
		- 좌측부터 **초기화된 전역 변수**/ **초기화되지 않은 전역 변수**/ **읽기 전용 데이터**
	- `.symtab` 섹션
		- 함수, 전역변수 등의 심볼 정보를 포함
	- `.rel.text`/ `.rel.data` 섹션
		- **재배치(Relocation) 정보**가 포함되며, 이는 오브젝트 파일의 중요한 특징이다.
		- 재배치 정보 예시
		```sql
		  Relocation section '.rel.text' at offset 0x5c contains 1 entry:
		  Offset     Info    Type            Sym.Value  Sym.Name
		  00000008   00000206 R_X86_64_PC32  00000000   printf 
		```

## 동적 링킹(Dynamic Linking)
상기한 Linking 과정은 일반적으로 **정적 링킹(static linking)** 이라고 한다. 이는 프로그램이 실행되기 이전에 모든 필요한 오브젝트 코드들을 연결하는 과정을 의미한다.

그러나 프로그램 실행 도중, 즉 **런타임**에 오브젝트 코드가 필요하면 해당 시점에 linking을 수행할 수도 있다. 이를 **동적 링킹(Dynamic linking)** 이라고 한다.

### Dynamic linking의 이점
> 동적 링킹을 사용하면 **시간**과 **메모리 공간 절약**이 가능하다. 또한, 여러 프로그램이 하나의 오브젝트 파일을 공유할 수도 있다. 그래서 이렇게 동적 링킹을 지원하는 오브젝트 파일을 **공유 라이브러리**라고 한다.

\*Windows에서는 **DLL(Dynamically Linking Library)** 라고 한다.

# 로더(Loader)
로더는 링커에 의해 만들어진 실행 파일을 메인 메모리에 적재하는 로딩 기능을 수행한다. 

링커가 오브젝트 파일을 연결하여 만든 실행 파일은 보조 저장 장치에 저장되어 있으므로 로더는 해당 프로그램을 메모리에 적재하여야 한다.

프로그램이 메모리에 할당되면 아래와 같은 구조를 가진다. 이제 로더가 어떤 프로세스로 프로그램을 로딩하는지 알아보자.

![[Pasted image 20250306120121.png]]

1. 실행 파일 역시 ELF 표준을 따르므로 ELF 파일 헤더가 있을 것이다. 로더는 헤더를 읽고 **텍스트 및 데이터 세그먼트의 크기를 결정**한다.
2. 각 데이터 세그먼트에 대해 충분히 큰 새 주소 공간을 생성한다.
3. 실행 파일의 **명령(text segment)** 과 **데이터(data segment)** 를 새 주소 공간으로 복사한다.
4. **매개변수**가 있다면 Stack에 복사한다.
5. register 초기화 및 Stack 포인터 설정
6. Stack에서 register로 매개변수를 복사하고 프로그램의 메인 루틴을 호출하는 **시작 루틴으로 점프**
7. 메인 루틴이 끝나면(returning) **종료 시스템 콜(exit system call)** 을 통해 프로그램 종료




>(5) Reference
- https://sepang2.tistory.com/34
- https://ko.wikipedia.org/wiki/ELF_%ED%8C%8C%EC%9D%BC_%ED%98%95%EC%8B%9D

